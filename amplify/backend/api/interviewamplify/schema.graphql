input CreateInterviewInput {
	id: ID
	title: String!
	profileInterviewsId: ID
}

input CreateMessageInput {
	id: ID
	sender: String!
	message: String!
	direction: String!
	ModelSubscriptionMessageFilterInput: ID
}

input CreateProfileInput {
	id: ID
	name: String!
}

input DeleteInterviewInput {
	id: ID!
}

input DeleteMessageInput {
	id: ID!
}

input DeleteProfileInput {
	id: ID!
}

type Interview @model {
	id: ID!
	title: String!
	profileInterviewsId: ID!
	messages(sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelMessageConnection
	createdAt: AWSDateTime!
	updatedAt: AWSDateTime!
}

type Message @model {
	id: ID!
	sender: String!
	messageInterviewId: ID!
	message: String!
	direction: String
	createdAt: AWSDateTime!
	updatedAt: AWSDateTime!
}

enum ModelAttributeTypes {
	binary
	binarySet
	bool
	list
	map
	number
	numberSet
	string
	stringSet
	_null
}

input ModelBooleanInput {
	ne: Boolean
	eq: Boolean
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
}

input ModelFloatInput {
	ne: Float
	eq: Float
	le: Float
	lt: Float
	ge: Float
	gt: Float
	between: [Float]
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
}

input ModelIDInput {
	ne: ID
	eq: ID
	le: ID
	lt: ID
	ge: ID
	gt: ID
	contains: ID
	notContains: ID
	between: [ID]
	beginsWith: ID
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
	size: ModelSizeInput
}

input ModelIntInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: [Int]
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
}

input ModelInterviewConditionInput {
	title: ModelStringInput
	and: [ModelInterviewConditionInput]
	or: [ModelInterviewConditionInput]
	not: ModelInterviewConditionInput
	profileInterviewsId: ModelIDInput
}

type ModelInterviewConnection {
	items: [Interview]!
	nextToken: String
}

input ModelInterviewFilterInput {
	id: ModelIDInput
	title: ModelStringInput
	and: [ModelInterviewFilterInput]
	or: [ModelInterviewFilterInput]
	not: ModelInterviewFilterInput
	profileInterviewsId: ModelIDInput
}

input ModelMessageConditionInput {
	sender: ModelStringInput
	content: ModelStringInput
	and: [ModelMessageConditionInput]
	or: [ModelMessageConditionInput]
	not: ModelMessageConditionInput
	interviewMessageId: ModelIDInput
}

type ModelMessageConnection {
	items: [Message]!
	nextToken: String
}

input ModelMessageFilterInput {
	id: ModelIDInput
	sender: ModelStringInput
	content: ModelStringInput
	and: [ModelMessageFilterInput]
	or: [ModelMessageFilterInput]
	not: ModelMessageFilterInput
	interviewMessageId: ModelIDInput
}

input ModelProfileConditionInput {
	name: ModelStringInput
	and: [ModelProfileConditionInput]
	or: [ModelProfileConditionInput]
	not: ModelProfileConditionInput
}

type ModelProfileConnection {
	items: [Profile]!
	nextToken: String
}

input ModelProfileFilterInput {
	id: ModelIDInput
	name: ModelStringInput
	and: [ModelProfileFilterInput]
	or: [ModelProfileFilterInput]
	not: ModelProfileFilterInput
}

input ModelSizeInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: [Int]
}

enum ModelSortDirection {
	ASC
	DESC
}

input ModelStringInput {
	ne: String
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	contains: String
	notContains: String
	between: [String]
	beginsWith: String
	attributeExists: Boolean
	attributeType: ModelAttributeTypes
	size: ModelSizeInput
}

input ModelSubscriptionBooleanInput {
	ne: Boolean
	eq: Boolean
}

input ModelSubscriptionFloatInput {
	ne: Float
	eq: Float
	le: Float
	lt: Float
	ge: Float
	gt: Float
	between: [Float]
	in: [Float]
	notIn: [Float]
}

input ModelSubscriptionIDInput {
	ne: ID
	eq: ID
	le: ID
	lt: ID
	ge: ID
	gt: ID
	contains: ID
	notContains: ID
	between: [ID]
	beginsWith: ID
	in: [ID]
	notIn: [ID]
}

input ModelSubscriptionIntInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	between: [Int]
	in: [Int]
	notIn: [Int]
}

input ModelSubscriptionInterviewFilterInput {
	id: ModelSubscriptionIDInput
	title: ModelSubscriptionStringInput
	and: [ModelSubscriptionInterviewFilterInput]
	or: [ModelSubscriptionInterviewFilterInput]
}

input ModelSubscriptionMessageFilterInput {
	id: ModelSubscriptionIDInput
	sender: ModelSubscriptionStringInput
	content: ModelSubscriptionStringInput
	and: [ModelSubscriptionMessageFilterInput]
	or: [ModelSubscriptionMessageFilterInput]
}

input ModelSubscriptionProfileFilterInput {
	id: ModelSubscriptionIDInput
	name: ModelSubscriptionStringInput
	and: [ModelSubscriptionProfileFilterInput]
	or: [ModelSubscriptionProfileFilterInput]
}

input ModelSubscriptionStringInput {
	ne: String
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	contains: String
	notContains: String
	between: [String]
	beginsWith: String
	in: [String]
	notIn: [String]
}

type Mutation {
	createProfile(input: CreateProfileInput!, condition: ModelProfileConditionInput): Profile
	updateProfile(input: UpdateProfileInput!, condition: ModelProfileConditionInput): Profile
	deleteProfile(input: DeleteProfileInput!, condition: ModelProfileConditionInput): Profile
	createInterview(input: CreateInterviewInput!, condition: ModelInterviewConditionInput): Interview
	updateInterview(input: UpdateInterviewInput!, condition: ModelInterviewConditionInput): Interview
	deleteInterview(input: DeleteInterviewInput!, condition: ModelInterviewConditionInput): Interview
	createMessage(input: CreateMessageInput!): Message
	updateMessage(input: UpdateMessageInput!, condition: ModelMessageConditionInput): Message
	deleteMessage(input: DeleteMessageInput!, condition: ModelMessageConditionInput): Message
}

type Profile @model {
	id: ID!
	name: String!
	interviews(sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelInterviewConnection
	createdAt: AWSDateTime!
	updatedAt: AWSDateTime!
}

type Query {
	getProfile(id: ID!): Profile
	listProfiles(filter: ModelProfileFilterInput, limit: Int, nextToken: String): ModelProfileConnection
	getInterview(id: ID!): Interview
	listInterviews(filter: ModelInterviewFilterInput, limit: Int, nextToken: String): ModelInterviewConnection
	getMessage(id: ID!): Message
	listMessages(filter: ModelMessageFilterInput, limit: Int, nextToken: String): ModelMessageConnection
}

type Subscription {
	onCreateProfile(filter: ModelSubscriptionProfileFilterInput): Profile
		@aws_subscribe(mutations: ["createProfile"])
	onUpdateProfile(filter: ModelSubscriptionProfileFilterInput): Profile
		@aws_subscribe(mutations: ["updateProfile"])
	onDeleteProfile(filter: ModelSubscriptionProfileFilterInput): Profile
		@aws_subscribe(mutations: ["deleteProfile"])
	onCreateInterview(filter: ModelSubscriptionInterviewFilterInput): Interview
		@aws_subscribe(mutations: ["createInterview"])
	onUpdateInterview(filter: ModelSubscriptionInterviewFilterInput): Interview
		@aws_subscribe(mutations: ["updateInterview"])
	onDeleteInterview(filter: ModelSubscriptionInterviewFilterInput): Interview
		@aws_subscribe(mutations: ["deleteInterview"])
	onCreateMessage: Message
		@aws_subscribe(mutations: ["createMessage"])
	onUpdateMessage(filter: ModelSubscriptionMessageFilterInput): Message
		@aws_subscribe(mutations: ["updateMessage"])
	onDeleteMessage(filter: ModelSubscriptionMessageFilterInput): Message
		@aws_subscribe(mutations: ["deleteMessage"])
}

input UpdateInterviewInput {
	id: ID!
	title: String
	profileInterviewsId: ID
}

input UpdateMessageInput {
	id: ID!
	sender: String
	direction: String
	content: String
	interviewMessageId: ID
}

input UpdateProfileInput {
	id: ID!
	name: String
}